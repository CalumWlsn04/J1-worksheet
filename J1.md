1)
**Fault Localization** is a fancy way of saying this is you’re performing fault localization; you observe a program output that doesn’t match the expected output for some input, and now you need to fix one (or more) lines of code to get your program to work.

2)
- Your tests are not biased by your code
- Writing tests helps you think about how you might write code
- Writing tests helps you think about the requirements of your system

3)
- Checks for letters, numbers and underscores, if there is anything else, it is bad
  - Checks for at least one uppercase letter
  - Checks for at least one lowercase letter
  - Checks for at least one number
- Check for no gmail in the password

4)
| a > b | G | x < y | Predicate outcome | Clause responsible |
|-------|---|-------|-------------------|--------------------|
|   1   | 0 |   0   |         0         |      (x < y)       |
|   1   | 1 |   0   |         0         |      (x < y)       |
|   1   | 1 |   1   |         1         |        Both        |
|   1   | 0 |   1   |         1         |        Both        |
|   0   | 1 |   0   |         0         |      (x < y)       |
|   0   | 1 |   1   |         1         |        Both        |
|   0   | 0 |   1   |         0         |   ((a > b) or G)   |
|   0   | 0 |   0   |         0         |        Both        |

6) None of the paths would achieve full path coverage as a test criteria. Either way we miss some of the nodes considering multiple paths and only single directions between them. This is a infinite set because of the infinite loop at 3 to 4, which can theoretically run forever.
   
7) Mutation testing is beneficial over other testing methods in that we can test our test cases by **seeding faults** into our program, in order to further test the code to its limits. This is a necessary idea for debugging in a high industry standard. [This is a link to our notes on *mutation testing*](https://cs2113-f24.github.io/j/software_testing)

8) 




